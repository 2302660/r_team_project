"<b>Records Lost (in Millions):</b> &nbsp;&nbsp;",
selected_point$records_lost,
"<br>",
"<b>Method:</b> &nbsp;&nbsp;",
selected_point$method,
"<br>",
"<b>Data Sensitivity:</b> &nbsp;&nbsp;",
selected_point$data_sensitivity,
"<br>",
"<b>Story:</b> &nbsp;&nbsp;",
selected_point$story,
"<br>",
"<b>Source:</b> &nbsp;&nbsp; <a href='",
selected_point$source_link,
"' target='_blank'>Link</a>",
"</div>"
)
)
})
} else {
output$detailPanel <- renderUI("Selected point not found in the filtered data.")
}
}
})
}
# Run the application
runApp(list(ui = ui, server = server), launch.browser = TRUE)
library(shiny)
library(shinythemes)
library(plotly)
library(tidyverse)
library(scales)
# Read data
data <- read.csv("dataset/cleaned_breaches.csv")
# Convert 'records_lost' to millions and round to 2 decimal places
data <- data %>%
mutate(records_lost = round(records_lost / 1e6, 2))
# Format numbers to avoid scientific notation and append 'M' suffix
data <- data %>%
mutate(records_lost = format(records_lost, scientific = FALSE))
# Define UI
ui <- fluidPage(
theme = shinytheme("superhero"),
tags$style(HTML("
.control-label {
font-size: 18px;
}
")),
titlePanel("Data Breach Analysis Portal"),
sidebarLayout(
sidebarPanel(
selectInput(
"year",
"Year",
choices = sort(unique(data$year), decreasing = TRUE),
selected = NULL,
multiple = TRUE
),
selectInput(
"organisation",
"Organisation",
choices = unique(data$organisation),
selected = NULL,
multiple = TRUE
)
),
mainPanel(
plotlyOutput("bubblePlot", height = "450px"),
HTML("<h3 style='color: orange;'><b>More Details:</b></h3>"),
# Title for the display area
htmlOutput("detailPanel")  # Output area for clicked point details
)
)
)
# Define server logic
server <- function(input, output, session) {
# Reactive function to filter data based on selections
filteredData <- reactive({
req(input$year, input$organisation)
data %>%
filter(year %in% input$year, organisation %in% input$organisation) %>%
mutate(id = row_number())  # Add a unique identifier for each row
})
# Generate plot output
output$bubblePlot <- renderPlotly({
p <- ggplot(
filteredData(),
aes(
year,
records_lost,
fill = method,
size = data_sensitivity,
customdata = id
)
) +
geom_point(aes(
text = paste(
"<br><b>Year:</b> ",
year,
"<br><b>Organisation:</b> ",
organisation,
"<br><b>Records Lost (in Millions):</b>",
records_lost,
"<br><b>Method:</b> ",
method,
"<br><b>Data Sensitivity:</b> ",
data_sensitivity
)
), alpha = 0.5, na.rm = TRUE) +
scale_x_continuous(breaks = seq(min(data$year), max(data$year), by = 1)) +
labs(title = "Trends in Data Breaches Over Time", x = "Year", y = "Records Lost (in Millions)") +
theme_gray() +
theme(
plot.title = element_text(
size = 20,
face = "bold",
family = "Arial"
),
# Title size & font
axis.title.x = element_text(size = 14, margin = margin(15, 0, 15, 0)),
# X-axis title size and margin
axis.title.y = element_text(size = 14, margin = margin(0, 15, 0, 15)),
# Y-axis title size and margin,
axis.text.x = element_text(size = 10),
# X-axis text size
axis.text.y = element_text(size = 10),
# Y-axis text size
legend.title = element_text(face = "bold", size = 12),
# Adjust the size of the legend title
legend.text = element_text(size = 10),
# Adjust the size of the legend text
legend.key.size = unit(10, "cm"),
# Adjust the size of the legend keys
legend.background = element_rect(fill = "white", colour = "darkblue"),
legend.box.margin = margin(10, 10, 10, 10)  # Adjust the margin around the legend
)
ggplotly(p, tooltip = "text") %>%
layout(hoverlabel = list(align = "left"))
})
# Capture and display click information
observeEvent(event_data("plotly_click"), {
click_data <- event_data("plotly_click")
if (is.null(click_data)) {
output$detailPanel <- renderUI("Click on a point to see details.")
} else {
# Extract the custom data (unique ID) from the click event
clicked_id <- click_data$customdata
df <- filteredData()
# Find the row corresponding to the clicked ID
selected_point <- df %>% filter(id == clicked_id)
if (nrow(selected_point) == 1) {
output$detailPanel <- renderUI({
HTML(
paste0(
"<div style='border: 3px solid #ccc; padding: 10px; border-radius: 10px; width: 850px; font-size: 16px;'>",
"<b>Year:</b> &nbsp;&nbsp;",
selected_point$year,
"&nbsp;&nbsp;&nbsp;&nbsp; <b>Month:</b> &nbsp;&nbsp;",
selected_point$month,
"<br>",
"<b>Organisation:</b> &nbsp;&nbsp;",
selected_point$organisation,
"<br>",
"<b>Sector:</b> &nbsp;&nbsp;",
selected_point$sector,
"<br>",
"<b>Records Lost (in Millions):</b> &nbsp;&nbsp;",
selected_point$records_lost,
"<br>",
"<b>Method:</b> &nbsp;&nbsp;",
selected_point$method,
"<br>",
"<b>Data Sensitivity:</b> &nbsp;&nbsp;",
selected_point$data_sensitivity,
"<br>",
"<b>Story:</b> &nbsp;&nbsp;",
selected_point$story,
"<br>",
"<b>Source:</b> &nbsp;&nbsp; <a href='",
selected_point$source_link,
"' target='_blank'>Link</a>",
"</div>"
)
)
})
} else {
output$detailPanel <- renderUI("Selected point not found in the filtered data.")
}
}
})
}
# Run the application
runApp(list(ui = ui, server = server), launch.browser = TRUE)
library(shiny)
library(shinythemes)
library(plotly)
library(tidyverse)
library(scales)
# Read data
data <- read.csv("dataset/cleaned_breaches.csv")
# Convert 'records_lost' to millions and round to 2 decimal places
data <- data %>%
mutate(records_lost = round(records_lost / 1e6, 2))
# Format numbers to avoid scientific notation and append 'M' suffix
data <- data %>%
mutate(records_lost = format(records_lost, scientific = FALSE))
# Define UI
ui <- fluidPage(
theme = shinytheme("superhero"),
tags$style(HTML("
.control-label {
font-size: 18px;
}
")),
titlePanel("Data Breach Analysis Portal"),
sidebarLayout(
sidebarPanel(
selectInput(
"year",
"Year",
choices = sort(unique(data$year), decreasing = TRUE),
selected = NULL,
multiple = TRUE
),
selectInput(
"organisation",
"Organisation",
choices = sort(unique(data$organisation)),
selected = NULL,
multiple = TRUE
)
),
mainPanel(
plotlyOutput("bubblePlot", height = "450px"),
HTML("<h3 style='color: orange;'><b>More Details:</b></h3>"),
# Title for the display area
htmlOutput("detailPanel")  # Output area for clicked point details
)
)
)
# Define server logic
server <- function(input, output, session) {
# Reactive function to filter data based on selections
filteredData <- reactive({
req(input$year, input$organisation)
data %>%
filter(year %in% input$year, organisation %in% input$organisation) %>%
mutate(id = row_number())  # Add a unique identifier for each row
})
# Generate plot output
output$bubblePlot <- renderPlotly({
p <- ggplot(
filteredData(),
aes(
year,
records_lost,
fill = method,
size = data_sensitivity,
customdata = id
)
) +
geom_point(aes(
text = paste(
"<br><b>Year:</b> ",
year,
"<br><b>Organisation:</b> ",
organisation,
"<br><b>Records Lost (in Millions):</b>",
records_lost,
"<br><b>Method:</b> ",
method,
"<br><b>Data Sensitivity:</b> ",
data_sensitivity
)
), alpha = 0.5, na.rm = TRUE) +
scale_x_continuous(breaks = seq(min(data$year), max(data$year), by = 1)) +
labs(title = "Trends in Data Breaches Over Time", x = "Year", y = "Records Lost (in Millions)") +
theme_gray() +
theme(
plot.title = element_text(
size = 20,
face = "bold",
family = "Arial"
),
# Title size & font
axis.title.x = element_text(size = 14, margin = margin(15, 0, 15, 0)),
# X-axis title size and margin
axis.title.y = element_text(size = 14, margin = margin(0, 15, 0, 15)),
# Y-axis title size and margin,
axis.text.x = element_text(size = 10),
# X-axis text size
axis.text.y = element_text(size = 10),
# Y-axis text size
legend.title = element_text(face = "bold", size = 12),
# Adjust the size of the legend title
legend.text = element_text(size = 10),
# Adjust the size of the legend text
legend.key.size = unit(10, "cm"),
# Adjust the size of the legend keys
legend.background = element_rect(fill = "white", colour = "darkblue"),
legend.box.margin = margin(10, 10, 10, 10)  # Adjust the margin around the legend
)
ggplotly(p, tooltip = "text") %>%
layout(hoverlabel = list(align = "left"))
})
# Capture and display click information
observeEvent(event_data("plotly_click"), {
click_data <- event_data("plotly_click")
if (is.null(click_data)) {
output$detailPanel <- renderUI("Click on a point to see details.")
} else {
# Extract the custom data (unique ID) from the click event
clicked_id <- click_data$customdata
df <- filteredData()
# Find the row corresponding to the clicked ID
selected_point <- df %>% filter(id == clicked_id)
if (nrow(selected_point) == 1) {
output$detailPanel <- renderUI({
HTML(
paste0(
"<div style='border: 3px solid #ccc; padding: 10px; border-radius: 10px; width: 850px; font-size: 16px;'>",
"<b>Year:</b> &nbsp;&nbsp;",
selected_point$year,
"&nbsp;&nbsp;&nbsp;&nbsp; <b>Month:</b> &nbsp;&nbsp;",
selected_point$month,
"<br>",
"<b>Organisation:</b> &nbsp;&nbsp;",
selected_point$organisation,
"<br>",
"<b>Sector:</b> &nbsp;&nbsp;",
selected_point$sector,
"<br>",
"<b>Records Lost (in Millions):</b> &nbsp;&nbsp;",
selected_point$records_lost,
"<br>",
"<b>Method:</b> &nbsp;&nbsp;",
selected_point$method,
"<br>",
"<b>Data Sensitivity:</b> &nbsp;&nbsp;",
selected_point$data_sensitivity,
"<br>",
"<b>Story:</b> &nbsp;&nbsp;",
selected_point$story,
"<br>",
"<b>Source:</b> &nbsp;&nbsp; <a href='",
selected_point$source_link,
"' target='_blank'>Link</a>",
"</div>"
)
)
})
} else {
output$detailPanel <- renderUI("Selected point not found in the filtered data.")
}
}
})
}
# Run the application
runApp(list(ui = ui, server = server), launch.browser = TRUE)
library(tidyverse)
library(shiny)
library(scales)
# Load data
data <- read_csv("dataset/cleaned_breaches.csv")
#remove commas
data$`records_lost` <- gsub(",", "", data$`records_lost`)
data$`records_lost` <- gsub(";", "", data$`records_lost`)
# convert chr to numeric
data$`records_lost` <- as.integer(data$`records_lost`)
# mutate match month.abb with data$month into a new column
data <- data %>% mutate(month.abb = match(data$month, month.abb))
data <- data %>% mutate(records_lost_m = `records_lost` / 1000000)
data <- data %>% mutate(records_lost_k = `records_lost` / 1000)
# identify duplicates and append the year to duplicates
data <- data %>%
group_by(organisation) %>%
mutate(dup = n() > 1,
unique_org_year = ifelse(dup, paste(organisation, year, sep = "_"), organisation)) %>%
ungroup()
head(data)
data_2024 <- data %>% filter(year == 2024)
head(data_2024)
head(data_2024)
data_2024 <- data_2024 %>%
mutate(name = fct_reorder(organisation, records_lost_m)) # to order the data in the graph
ggplot(data_2024, aes(x = name, y = records_lost_m)) +
geom_segment(aes(
x = name,
xend = organisation,
y = 0,
yend = records_lost_m
)) +
geom_point(size = 4,
alpha = 0.6,
color = "orange") +
scale_y_log10(labels = label_number()) +
coord_flip() +
theme_gray()
# SHINY APP
sectorFilter <- c(unique(data$sector), "All")
ui <- fluidPage(
theme = bslib::bs_theme(bootswatch = "flatly"),
titlePanel("Data Breaches in History"),
sidebarLayout(
sidebarPanel(
# inputs
selectInput(
"Years",
"Filter by Years",
choices = sort(unique(data$year), decreasing = TRUE),
selected = c(2024),
multiple = TRUE
),
sliderInput(
"val_top",
"Show the top n Records:",
min = 1,
max = 30,
value = 10,
step = 1
),
# Data information when you hover etc.
verbatimTextOutput("info")
),
mainPanel(
plotOutput(
"plot",
width = "900px",
height = "600px"
),
verbatimTextOutput("summary")
)
)
)
# server function
server <- function(input, output, session) {
# Reactive expression to calculate max records for current selected years
max_records <- reactive({
data %>% filter(year %in% input$Years) %>% nrow()
})
# Observes changes in selected years and update the sliderInput
observe({
max_recs <- max(1, max_records())
updateSliderInput(session, "val_top", max = max_recs, value = min(input$val_top, max_recs))
})
output$plot <- renderPlot({
# Filter data for the selected years
data_plot <- data %>% filter(year %in% input$Years)
# Calculate top N records from the combined dataset
top_n_combined <- data_plot %>%
mutate(name = fct_reorder(unique_org_year, records_lost_m)) %>%
mutate(Rank = rank(-records_lost_m, ties.method = "average")) %>%
arrange(Rank) %>%
group_by(year) %>%
slice_head(n = input$val_top) %>%
ungroup() %>%
arrange(-records_lost_m) %>%
slice_head(n = input$val_top)
ggplot(top_n_combined, aes(x = name, y = records_lost_m, color = as.factor(year))) +
geom_segment(aes(
x = name,
xend = name,
y = 0,
yend = records_lost_m
)) +
geom_point(size = 4, alpha = 0.6) +
scale_y_log10(labels = label_number()) +
labs(title = "Data Breach Overview", x = "Organisations", y = "Records Lost (in millions)", color = "Year") +
coord_flip() +
theme_gray()
}, res = 96)
output$info <- renderText({
# Filter data for the selected years
data_plot <- data %>% filter(year %in% input$Years)
# Calculate top N records from the combined dataset
top_n_combined <- data_plot %>%
mutate(name = fct_reorder(unique_org_year, records_lost_m)) %>%
mutate(Rank = rank(-records_lost_m, ties.method = "average")) %>%
arrange(Rank) %>%
group_by(year) %>%
slice_head(n = input$val_top) %>%
ungroup() %>%
arrange(-records_lost_m) %>%
slice_head(n = input$val_top)
# Sort selected years in ascending order
sorted_years <- sort(input$Years)
top_text <- top_n_combined %>%
mutate(Info = paste(
Rank,
": ",
name,
" - Records Lost (in Millions): ",
records_lost_m,
" - Year: ",
year
)) %>%
pull(Info) %>%
paste(collapse = "\n")
paste0(
"Years: ",
paste(sorted_years, collapse = ", "),
"\n",
"Total Records Lost (in Millions): ",
sum(top_n_combined$records_lost_m),
"\n\n",
"Top Rankings:\n",
top_text
)
})
}
# Run the application
runApp(list(ui = ui, server = server), launch.browser = TRUE)
